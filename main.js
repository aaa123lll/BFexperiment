(()=>{var n={203:(n,e,t)=>{"use strict";t.d(e,{A:()=>p});var a=t(278),r=t.n(a),i=t(911),o=t.n(i)()(r());o.push([n.id,"textarea.code_editor {\n    width: 90%;\n    /* height: 200px; */\n    background-color: #2e3440;\n    color: #d8dee9;\n    font-family: 'Courier New', Courier, monospace;\n    font-size: 14px;\n    padding: 10px;\n    border: 1px solid #4c566a;\n    border-radius: 4px;\n    outline: none;\n    resize: none;\n    line-height: 1.5;\n    tab-size: 4;\n}",""]);const p=o},911:n=>{"use strict";n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var t="",a=void 0!==e[5];return e[4]&&(t+="@supports (".concat(e[4],") {")),e[2]&&(t+="@media ".concat(e[2]," {")),a&&(t+="@layer".concat(e[5].length>0?" ".concat(e[5]):""," {")),t+=n(e),a&&(t+="}"),e[2]&&(t+="}"),e[4]&&(t+="}"),t})).join("")},e.i=function(n,t,a,r,i){"string"==typeof n&&(n=[[null,n,void 0]]);var o={};if(a)for(var p=0;p<this.length;p++){var l=this[p][0];null!=l&&(o[l]=!0)}for(var s=0;s<n.length;s++){var u=[].concat(n[s]);a&&o[u[0]]||(void 0!==i&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=i),t&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=t):u[2]=t),r&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=r):u[4]="".concat(r)),e.push(u))}},e}},278:n=>{"use strict";n.exports=function(n){return n[1]}},31:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>_});var a=t(157),r=t.n(a),i=t(338),o=t.n(i),p=t(594),l=t.n(p),s=t(549),u=t.n(s),c=t(41),d=t.n(c),m=t(398),y=t.n(m),f=t(203),h={};h.styleTagTransform=y(),h.setAttributes=u(),h.insert=l().bind(null,"head"),h.domAPI=o(),h.insertStyleElement=d(),r()(f.A,h);const _=f.A&&f.A.locals?f.A.locals:void 0},157:n=>{"use strict";var e=[];function t(n){for(var t=-1,a=0;a<e.length;a++)if(e[a].identifier===n){t=a;break}return t}function a(n,a){for(var i={},o=[],p=0;p<n.length;p++){var l=n[p],s=a.base?l[0]+a.base:l[0],u=i[s]||0,c="".concat(s," ").concat(u);i[s]=u+1;var d=t(c),m={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==d)e[d].references++,e[d].updater(m);else{var y=r(m,a);a.byIndex=p,e.splice(p,0,{identifier:c,updater:y,references:1})}o.push(c)}return o}function r(n,e){var t=e.domAPI(e);return t.update(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap&&e.supports===n.supports&&e.layer===n.layer)return;t.update(n=e)}else t.remove()}}n.exports=function(n,r){var i=a(n=n||[],r=r||{});return function(n){n=n||[];for(var o=0;o<i.length;o++){var p=t(i[o]);e[p].references--}for(var l=a(n,r),s=0;s<i.length;s++){var u=t(i[s]);0===e[u].references&&(e[u].updater(),e.splice(u,1))}i=l}}},594:n=>{"use strict";var e={};n.exports=function(n,t){var a=function(n){if(void 0===e[n]){var t=document.querySelector(n);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(n){t=null}e[n]=t}return e[n]}(n);if(!a)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");a.appendChild(t)}},41:n=>{"use strict";n.exports=function(n){var e=document.createElement("style");return n.setAttributes(e,n.attributes),n.insert(e,n.options),e}},549:(n,e,t)=>{"use strict";n.exports=function(n){var e=t.nc;e&&n.setAttribute("nonce",e)}},338:n=>{"use strict";n.exports=function(n){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var e=n.insertStyleElement(n);return{update:function(t){!function(n,e,t){var a="";t.supports&&(a+="@supports (".concat(t.supports,") {")),t.media&&(a+="@media ".concat(t.media," {"));var r=void 0!==t.layer;r&&(a+="@layer".concat(t.layer.length>0?" ".concat(t.layer):""," {")),a+=t.css,r&&(a+="}"),t.media&&(a+="}"),t.supports&&(a+="}");var i=t.sourceMap;i&&"undefined"!=typeof btoa&&(a+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i))))," */")),e.styleTagTransform(a,n,e.options)}(e,n,t)},remove:function(){!function(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n)}(e)}}}},398:n=>{"use strict";n.exports=function(n,e){if(e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},e={};function t(a){var r=e[a];if(void 0!==r)return r.exports;var i=e[a]={id:a,exports:{}};return n[a](i,i.exports,t),i.exports}let a;t.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return t.d(e,{a:e}),e},t.d=(n,e)=>{for(var a in e)t.o(e,a)&&!t.o(n,a)&&Object.defineProperty(n,a,{enumerable:!0,get:e[a]})},t.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),t.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.nc=void 0,t(31);const r=document.getElementById("elenumberULA"),i=document.getElementById("ULAusr");let o=document.getElementById("codeULA");document.getElementById("runcodeULAbtn").addEventListener("click",P),document.getElementById("runcodeULAsamplebtn").addEventListener("click",(async function(){o.value="def Modified_element(num_N, w, maxdre):\n    results = []\n    def calculate(arr, idx):\n        if idx == num_N:\n            xxx, yyy = ULAfunction(num_N, arr)\n            val = yyy[maxdre]\n            mmm = arr.copy()\n            results.append((mmm, val))\n            return\n        arr[idx] = 0\n        calculate(arr[:], idx + 1)\n        arr[idx] = 1\n        calculate(arr[:], idx + 1)\n    calculate(w, 0)\n    max_val=0\n    for combo, result in results:\n        if result > max_val:\n            max_val = result\n            max_combo = combo\n    return max_combo\n        ",P()}));const p=document.getElementById("outputULA");p.value="initializing...\n";const l=document.getElementById("plot-containerframeULA"),s=document.getElementById("codeULAshow"),u=document.getElementById("elenumberUPAx"),c=document.getElementById("elenumberUPAy"),d=document.getElementById("UPAphi"),m=document.getElementById("UPAtheta"),y=document.getElementById("codeUPA");document.getElementById("runcodeUPAbtn").addEventListener("click",j),document.getElementById("runcodeUPAsamplebtn").addEventListener("click",(async function(){y.value="def opt(Nx,Ny,w,theta,phi):\n    total_configurations = 2 ** (Nx * Ny)\n\n    matrices = []\n    for config in range(total_configurations):\n        binary_str = np.binary_repr(config, width=Nx * Ny)\n        matrix = np.array(list(binary_str), dtype=int).reshape((Nx, Ny))\n        gain_usr=steeringVectorUPA(Nx, Ny, theta, phi,matrix, dx=0.5, dy=0.5)\n        matrices.append((matrix,np.abs(gain_usr.sum()) ** 2))\n    max_val = 0\n    for combo, result in matrices:\n        if result > max_val:\n            max_val = result\n            max_combo = combo\n    return max_combo",j()}));const f=document.getElementById("outputUPA");f.value="initializing...\n";const h=document.getElementById("plot-containerframeUPA"),_=document.getElementById("codeUPAshow"),g=document.getElementById("elenumberULAmult"),x=document.getElementById("ULAmultusr"),w=document.getElementById("disturb1dre"),b=document.getElementById("disturb2dre"),A=document.getElementById("codeULAmult");document.getElementById("runcodeULAmultbtn").addEventListener("click",I),document.getElementById("runcodeULAmultsamplebtn").addEventListener("click",(async function(){A.value='def optimizedfuc(M,theta_0,theta_1,theta_2,w):\n\n    phi_0 = np.zeros(M)\n    phi_1 = np.zeros(M)\n    phi_2 = np.zeros(M)\n    for j in range(M):\n        phi_0[j] = 2 * np.pi / lamda * (j - 1) * d * np.sin(theta_0)  # 服务用户方向的阵列响应向量\n        phi_1[j] = 2 * np.pi / lamda * (j - 1) * d * np.sin(theta_1)  # 干扰用户1方向的阵列响应向量\n        phi_2[j] = 2 * np.pi / lamda * (j - 1) * d * np.sin(theta_2)  # 干扰用户2方向的阵列响应向量\n    aa = np.exp(1j * phi_0)  # 服务用户的天线阵列响应向量\n    in_ar_1 = np.exp(1j * phi_1)  # 干扰用户1的天线阵列响应向量\n    in_ar_2 = np.exp(1j * phi_2)  # 干扰用户2的天线阵列响应向量\n\n    ww = np.zeros((2 ** (k * M), M * k), dtype=int)\n    AnaW = np.zeros((2 ** (k * M), M), dtype=complex)  # 存储相控矩阵\n    Gain = np.zeros(2 ** (k * M))  # 记录不同天线调相方案当前用户获得的阵列SIR\n    Interf = np.zeros(2 ** (k * M))  # 记录干扰用户阵列增益\n\n    for m in range(1, 2 ** (M * k)):\n        temp = m\n        j = 0\n        temp2 = temp // 2\n        ww[m, M * k - j - 1] = temp - temp2 * 2\n        temp = temp2\n\n        while temp != 0:\n            j += 1\n            temp2 = temp // 2\n            ww[m, M * k - j - 1] = temp - temp2 * 2\n            temp = temp2\n\n        for mm in range(M):\n            tempPhi = int("".join(map(str, ww[m, mm * k:(mm + 1) * k])), 2)\n            tempW = np.exp(1j * tempPhi * 2 * np.pi / 2 ** k)\n            AnaW[m, mm] = tempW\n\n        Gain[m] = abs(AnaW[m, :] @ aa) / (abs(AnaW[m, :] @ in_ar_1) + abs(AnaW[m, :] @ in_ar_2))  # 计算不同天线选择方案当前用户获得的阵列SIR\n\n    Gain_ori = abs(np.sum(aa)) / (abs(np.sum(in_ar_1)) + abs(np.sum(in_ar_2)))\n\n    n_index = np.argmax(Gain)\n    w_opt = AnaW[n_index]\n\n    return w_opt\n            ',I()}));const v=document.getElementById("outputULAmult");v.value="initializing...\n";const N=document.getElementById("plot-containerframeULAmult"),U=document.getElementById("codeULAmultshow");function M(n,e){n.value+=">>>"+e+"\n"}async function P(){const n=r.value,e=i.value;let t="\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom io import BytesIO\nimport base64\n\ndef steeringVectorULA(N, theta, d=0.5):\n    n = np.arange(N)\n    A = np.exp(1j * 2 * np.pi * d * n * np.cos(theta))\n    return A\n\n# 在w条件下得到增益\ndef ULAfunction(num_N,w):\n    theta = np.linspace(0, 2 * np.pi, 360)\n    BF = np.ones(num_N)\n    gain_ULA = np.zeros(theta.shape)\n    for i, tt in enumerate(theta):\n        # print(tt)\n        sv = steeringVectorULA(num_N, tt, d=0.5)\n        sv = sv * w\n        gain_ULA[i] = np.dot(sv, BF)\n    return theta,gain_ULA\ndef pltULA(theta,gain_ULA,user_direction):\n    fig = plt.figure()\n    ax = fig.add_subplot(projection='polar')\n    ax.plot(theta, np.abs(gain_ULA))\n\n\n    user_direction = np.deg2rad(user_direction)  # 将角度转换为弧度\n    ax.plot([user_direction, user_direction], [0, max(np.abs(gain_ULA))], color='red', linestyle='--', linewidth=2)\n    plt.text(0.5, 0.95, 'Red dashed line: User direction', horizontalalignment='center', \n    verticalalignment='center', transform=ax.transAxes, color='red', fontsize=10, \n    bbox=dict(facecolor='white', alpha=0.8, edgecolor='red'))\n    return fig\n    # plt.show()\n\n\n\n"+o.value+"\n"+`\nnum_N=${n}\n\nw=np.ones(num_N)\nw=Modified_element(num_N,w,${e})\n\ntheta,gain_ULA=ULAfunction(num_N,w)\nfig = pltULA(theta,gain_ULA,${e})\n\n\n# 将绘图对象保存到 BytesIO 对象中\nbuffer = BytesIO()\nplt.savefig(buffer, format='png')\nbuffer.seek(0)\n\n# 将 BytesIO 对象转换为 base64 编码的字符串\nplot_data = buffer.getvalue()\nplot_base64 = base64.b64encode(plot_data).decode('utf-8')\nplot_base64\n`;try{const n=await a.runPythonAsync(t);l.src=`data:image/png;base64,${n}`,console.log("plotting success."),M(p,"Plotting success.")}catch(n){M(n.message),console.error("Plotting failed:",n),l.innerText="An error occurred while plotting."}}async function j(){const n=u.value,e=c.value,t=m.value,r=d.value;let i="\nimport numpy as np\nimport micropip\nawait micropip.install('plotly')\nprint (\"micropip install success\")\n\nimport plotly.graph_objects as go\n\ndef steeringVectorUPA(Nx, Ny, theta, phi,w, dx=0.5, dy=0.5):\n    A = np.zeros((Nx, Ny), dtype='complex')\n    for n_x in range(Nx):\n        for n_y in range(Ny):\n            if w[n_x,n_y] ==1:\n                A[n_x, n_y] = np.exp(-1j * 2 * np.pi * np.sin(theta) * (n_x * dx * np.cos(phi) + n_y * dy * np.sin(phi)))\n    return A\n\ndef sphere2xzy(theta, phi, R):\n    X = R * np.sin(theta) * np.cos(phi)\n    Y = R * np.sin(theta) * np.sin(phi)\n    Z = R * np.cos(theta)\n    return X, Y, Z\n\ndef UPAfuction(Nx, Ny,w):\n    phi, theta = np.linspace(0, 2 * np.pi, 360), np.linspace(0, np.pi / 2, 90)\n    PHI, THETA = np.meshgrid(phi, theta)  ### 生成网格\n\n\n    gain_UPA = np.zeros(THETA.shape, dtype=complex)\n    for i in range(THETA.shape[0]):\n        for j in range(THETA.shape[1]):\n            sv = steeringVectorUPA(Nx, Ny, THETA[i, j], PHI[i, j],w, dx=0.5, dy=0.5)\n            gain_UPA[i, j] = np.abs(sv.sum()) ** 2\n\n    X, Y, Z = sphere2xzy(THETA, PHI, np.abs(gain_UPA))\n\n    # 使用plotly绘制三维表面图\n    fig = go.Figure(data=[go.Surface(x=X, y=Y, z=Z, colorscale='Jet')])\n    fig.update_layout(title='3D Surface plot', autosize=False,\n                      width=800, height=800,\n                      margin=dict(l=65, r=50, b=65, t=90))\n    # fig.show()\n    return fig.to_html(full_html=False)\n    \n"+y.value+"\n"+`\nnum_Nx=${n}\nnum_Ny=${e}\ntheta= ${t}/ 180 * np.pi\nphi= ${r}/ 180 * np.pi\nw=np.ones((num_Nx, num_Ny), dtype='complex')\n\nw_opt=opt(num_Nx,num_Ny,w,theta,phi)\n\nplot = UPAfuction(num_Nx,num_Ny,w_opt)\nprint("creat plot success")\nplot\n    `;try{const n=await a.runPythonAsync(i);h.srcdoc=n,console.log("plotting success."),M(f,"Plotting success.")}catch(n){M(f,n.message),console.error("Plotting failed:",n),h.srcdoc="<p>An error occurred while plotting.</p>"}}async function I(){let n=`\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom io import BytesIO\nimport base64\n\nM=${g.value}\nk = 4  # 定义波束赋形矩阵w的相位传输比特数\nMM = 2 ** k  # 定义波束赋形矩阵w的相位分辨率\nfc = 2e9  # 定义中心频率，单位Hz\nc = 3e8  # 定义光速\nlamda = c / fc  # 计算波长,单位为m\nd = lamda / 2  # 定义天线间距\nN = 1000  # 定义角度采样点数\ntheta = np.pi * np.linspace(-1, 1, N + 1)  # 获得采样角度, theta 范围为 -pi/2 到 pi/2\nphi = np.zeros((N + 1, M))  # 初始化天线阵列响应向量的相位值\nstr_label = f'M={M}, d=lambda/2'\n\nfor j in range(M):\n    phi[:, j] = 2 * np.pi / lamda * (j - 1) * d * np.sin(theta)\n\nw = np.ones(M)\na = np.exp(1j * phi)  # 获得天线阵列响应向量\nAF = w @ a.T  # 计算天线阵列增益\n\ntheta_0 = ${x.value} / 180 * np.pi  # 定义服务用户的方向\ntheta_1 = ${w.value} / 180 * np.pi  # 定义干扰用户1的方向\ntheta_2 = ${b.value} / 180 * np.pi  # 定义干扰用户2的方向\n\n# 用极坐标表示\nfig=plt.figure()\nax = plt.subplot(111, projection='polar')\nax.plot(np.mod(theta / np.pi * 180 + 360, 360) / 180 * np.pi, np.abs(AF),label='ori')\n\nax.plot([theta_0, theta_0], [0, max(np.abs(AF))], color='red', linestyle='--', linewidth=2,label='usr0')\nax.plot([theta_1, theta_1], [0, max(np.abs(AF))], color='green', linestyle='--', linewidth=2,label='usr1')\nax.plot([theta_2, theta_2], [0, max(np.abs(AF))], color='green', linestyle='--', linewidth=2,label='usr2')\n\nax.legend([str_label])\nax.set_title('Antenna Array Gain（ULA）')\n\n    \n`+A.value+"\n\nw_opt=optimizedfuc(M,theta_0,theta_1,theta_2,w)\na = np.exp(1j * phi)\nAF_opt = w_opt @ a.T\n\n# 用极坐标表示优化后的结果\nax = plt.subplot(111, projection='polar')\nax.plot(np.mod(theta / np.pi * 180 + 360, 360) / 180 * np.pi, np.abs(AF_opt),label='opt')\nax.legend()#[str_label]\nax.set_title('Antenna Array Gain（ULA）')\nplt.show()\n\n# 将绘图对象保存到 BytesIO 对象中\nbuffer = BytesIO()\nplt.savefig(buffer, format='png')\nbuffer.seek(0)\n\n# 将 BytesIO 对象转换为 base64 编码的字符串\nplot_data = buffer.getvalue()\nplot_base64 = base64.b64encode(plot_data).decode('utf-8')\nplot_base64\n    ";try{const e=await a.runPythonAsync(n);N.src=`data:image/png;base64,${e}`,console.log("plotting success."),M(v,"Plotting success.")}catch(n){M(v,n.message),console.error("Plotting failed:",n),N.innerText="An error occurred while plotting."}}(async()=>{try{await async function(){return a=await loadPyodide({indexURL:"https://cdn.jsdelivr.net/pyodide/v0.18.1/full/"}),await a.loadPackage("numpy"),await a.loadPackage("micropip"),await a.loadPackage("matplotlib"),a}(),p.value="Pyodide initialized successfully.\n",f.value="Pyodide initialized successfully.\n",v.value="Pyodide initialized successfully.\n",s.value='# 引用库\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef ULAfunction(num_N,w):\n    """  \n    计算均匀线性阵列在不同角度下的增益。可以直接进行调用，不用编写。\n        \n    参数:  \n    num_N: int - 天线元素的数量  \n    w: numpy.array - 权重数组,形状为 (num_N,)\n        \n    返回:  \n    theta: numpy.array - 角度数组  \n    gain_ULA: numpy.array - 对应的增益数组  \n    """  \n    return theta,gain_ULA\n\ndef Modified_element(num_N, w, maxdre):\n    """ \n    用于计算最优天线选择矩阵，需要在右侧代码框中进行完成。\n    输入：\n    num_N: int - 天线元素的数量  \n    w: numpy.array - 权重数组,用于指示哪些天线元素处于开启状态,1表示开启,0表示关闭,默认为元素值均为1、长度为num_N的一维数组,如:[1,1,1,1,1,1,1,1]\n    maxdre: float - 用户方向（单位：°）\n    返回：\n    w: numpy.array - 优化后的权重数组,长度为num_N的一维数组,如:[1,0,0,1,1,1,1,1]\n    """ \n    return w\nw=np.ones(num_N) # 初始天线选择矩阵 \nw=Modified_element(num_N,w,maxdre) # 由Modified_element函数计算得到最优天线选择矩阵\n        \ntheta,gain_ULA=ULAfunction(num_N,w) # 利用已得到的最优天线选择矩阵计算增益\nfig = pltULA(theta,gain_ULA,maxdre) # 绘制增益图\n        ',o.value='def Modified_element(num_N, w, maxdre):\n    """ \n    用于计算最优天线选择矩阵，需要在本代码中进行完成。\n    输入：\n    num_N: int - 天线元素的数量  \n    w: numpy.array - 权重数组,用于指示哪些天线元素处于开启状态,1表示开启,0表示关闭,默认为元素值均为1、长度为num_N的一维数组,如:[1,1,1,1,1,1,1,1]\n    maxdre: float - 用户方向（单位：°）\n    """ \n    return w  \n    # w: numpy.array - 优化后的权重数组,长度为num_N的一维数组,如:[1,0,0,1,1,1,1,1]',_.value='import numpy as np\n\ndef steeringVectorUPA(Nx, Ny, theta, phi, w, dx=0.5, dy=0.5):  \n    """  \n    计算均匀平面阵列 (UPA) 的在(theta,phi)方向下的增益，可以直接进行调用，不用编写。  \n\n    参数:  \n    Nx: int - 阵列在 x 方向上天线元素的数量  \n    Ny: int - 阵列在 y 方向上天线元素的数量  \n    theta: float - 入射角的水平角度（单位：°）\n    phi: float - 入射角的垂直角度（单位：°）\n    w: numpy.array - 权重数组，用于指示哪些天线元素处于开启状态,1表示开启，0表示关闭\n    w的形状为(Nx, Ny)，形如\n    [[1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1]]\n    dx: float - 相邻天线在 x 方向上的间距（默认值为 0.5）  \n    dy: float - 相邻天线在 y 方向上的间距（默认值为 0.5）  \n\n    返回:  \n    A: numpy.array - 均匀平面阵列的波束形成方向向量，形状为 (Nx, Ny)  \n    """  \n    return A\ndef opt(Nx, Ny, w, theta, phi):  \n    """  \n    优化均匀平面阵列 (UPA) 的天线配置，以最大化在特定角度下的增益，需要在右侧代码框中进行编写。  \n\n    参数:  \n    Nx: int - 阵列在 x 方向上天线元素的数量  \n    Ny: int - 阵列在 y 方向上天线元素的数量  \n    w: numpy.array - 权重数组，用于指示哪些天线元素处于开启状态,1表示开启，0表示关闭\n    w默认为形状为(Nx, Ny)的全1数组，如：\n    [[1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1]]\n    theta: float - 入射角的水平角度（单位：°）\n    phi: float - 入射角的垂直角度（单位：°）\n    返回：\n    w: numpy.array - 计算得到的具有最大增益的阵列配置，形状为(Nx, Ny) 的二进制数组,其中 1 表示天线开启，0 表示天线关闭  \n    如：\n    [[1,0,1,1],\n    [1,1,1,1],\n    [1,0,1,1],\n    [1,1,1,0]]\n    """\n    return w\nw=np.ones((num_Nx, num_Ny), dtype=\'complex\')  # 初始天线选择矩阵\nw_opt=opt(num_Nx,num_Ny,w,theta,phi)  # 由opt函数计算得到最优天线选择矩阵\nplot = UPAfuction(num_Nx,num_Ny,w_opt) # 绘制增益图\n        ',y.value='def opt(Nx,Ny,w,theta,phi):\n    """  \n    优化均匀平面阵列 (UPA) 的天线配置，以最大化在特定角度下的增益，需要在本代码中编写。  \n\n    参数:  \n    Nx: int - 阵列在 x 方向上天线元素的数量  \n    Ny: int - 阵列在 y 方向上天线元素的数量  \n    w: numpy.array - 权重数组，用于指示哪些天线元素处于开启状态,1表示开启，0表示关闭\n    w默认为形状为(Nx, Ny)的全1数组，如：\n    [[1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1]]\n    theta: float - 入射角的水平角度（单位：°）\n    phi: float - 入射角的垂直角度（单位：°）\n    """\n    return w\n    """\n    返回：\n    w: numpy.array - 计算得到的具有最大增益的阵列配置，形状为(Nx, Ny) 的二进制数组,其中 1 表示天线开启，0 表示天线关闭  \n    如：\n    [[1,0,1,1],\n    [1,1,1,1],\n    [0,1,1,1],\n    [1,1,1,0]]\n    """',U.value='import numpy as np\nimport matplotlib.pyplot as plt\n\nk = 4  # 定义波束赋形矩阵w的相位传输比特数\nMM = 2 ** k  # 定义波束赋形矩阵w的相位分辨率\nfc = 2e9  # 定义中心频率，单位Hz\nc = 3e8  # 定义光速\nlamda = c / fc  # 计算波长,单位为m\nd = lamda / 2  # 定义天线间距\nN = 1000  # 定义角度采样点数\ntheta = np.pi * np.linspace(-1, 1, N + 1)  # 获得采样角度, theta 范围为 -pi/2 到 pi/2\nphi = np.zeros((N + 1, M))  # 初始化天线阵列响应向量的相位值\nstr_label = f\'M={M}, d=lambda/2\'\n\nfor j in range(M):\n    phi[:, j] = 2 * np.pi / lamda * (j - 1) * d * np.sin(theta)\n\nw = np.ones(M) # 初始天线选择矩阵\na = np.exp(1j * phi)  # 获得天线阵列响应向量\nAF = w @ a.T  # 计算天线阵列增益\n\ntheta_0 = maxdre / 180 * np.pi  # 定义服务用户的方向\ntheta_1 = disturb1d  / 180 * np.pi  # 定义干扰用户1的方向\ntheta_2 = disturb2dre / 180 * np.pi  # 定义干扰用户2的方向\n\n\ndef optimizedfuc(M, theta_0, theta_1, theta_2, w):  \n    """  \n    优化天线调相方案以最大化服务用户的信号增益，最小化干扰，需要在右侧代码框中进行编写。\n\n    参数:  \n    M: int - 天线元素的数量  \n    theta_0: float - 服务用户的方向（已转换为弧度表示）  \n    theta_1: float - 干扰用户1的方向（已转换为弧度表示）  \n    theta_2: float - 干扰用户2的方向（已转换为弧度表示）  \n    w: numpy.array - 初始天线调相方案，长度为M的一维数组，默认所有元素为1，如[1,1,1,1]\n\n    返回:  \n    w: numpy.array - 能够使SIR值最大的天线调相方案，形状为长度为M的一维数组。\n    需要注意的是，经过计算后得到的w中的值是单位幅度的复数，即它们的模长为1，而相位根据不同的量化配置而变化\n    例如：[1 + 0j, 0.7071 + 0.7071j, 0 + 1j, -0.7071 + 0.7071j]\n    """\n    return w\nw_opt=optimizedfuc(M,theta_0,theta_1,theta_2) # 由optimizedfuc函数计算得到最优天线调相方案\na = np.exp(1j * phi) # 获得天线阵列响应向量\nAF_opt = w_opt @ a.T # 计算最优天线阵列增益\n\n    ',A.value='def optimizedfuc(M,theta_0,theta_1,theta_2,w):\n    """  \n    用于计算能够最大化服务用户的SIR值的天线调相方案，需要在本代码中进行编写。\n    参数:  \n    M: int - 天线元素的数量  \n    theta_0: float - 服务用户的方向（已转换为弧度表示）  \n    theta_1: float - 干扰用户1的方向（已转换为弧度表示）  \n    theta_2: float - 干扰用户2的方向（已转换为弧度表示）  \n    w: numpy.array - 初始天线调相方案，长度为M的一维数组，默认所有元素为1，如[1,1,1,1]\n    """\n    return w\n    """\n    返回:  \n    w: numpy.array - 能够使SIR值最大的天线调相方案，形状为长度为M的一维数组。\n    需要注意的是，经过计算后得到的w中的值是单位幅度的复数，即它们的模长为1，而相位根据不同的量化配置而变化\n    例如：[1 + 0j, 0.7071 + 0.7071j, 0 + 1j, -0.7071 + 0.7071j]\n    """',console.log("Pyodide initialized successfully.")}catch(n){console.error("Error while initializing Pyodide:",n)}})()})();