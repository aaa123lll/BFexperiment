(()=>{var n={300:(n,e,t)=>{"use strict";t.d(e,{A:()=>u});var a=t(898),r=t.n(a),o=t(75),i=t.n(o)()(r());i.push([n.id,"textarea.code_editor {\n    width: 90%;\n    /* height: 200px; */\n    background-color: #2e3440;\n    color: #d8dee9;\n    font-family: 'Courier New', Courier, monospace;\n    font-size: 14px;\n    padding: 10px;\n    border: 1px solid #4c566a;\n    border-radius: 4px;\n    outline: none;\n    resize: none;\n    line-height: 1.5;\n    tab-size: 4;\n}",""]);const u=i},75:n=>{"use strict";n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var t="",a=void 0!==e[5];return e[4]&&(t+="@supports (".concat(e[4],") {")),e[2]&&(t+="@media ".concat(e[2]," {")),a&&(t+="@layer".concat(e[5].length>0?" ".concat(e[5]):""," {")),t+=n(e),a&&(t+="}"),e[2]&&(t+="}"),e[4]&&(t+="}"),t})).join("")},e.i=function(n,t,a,r,o){"string"==typeof n&&(n=[[null,n,void 0]]);var i={};if(a)for(var u=0;u<this.length;u++){var d=this[u][0];null!=d&&(i[d]=!0)}for(var l=0;l<n.length;l++){var c=[].concat(n[l]);a&&i[c[0]]||(void 0!==o&&(void 0===c[5]||(c[1]="@layer".concat(c[5].length>0?" ".concat(c[5]):""," {").concat(c[1],"}")),c[5]=o),t&&(c[2]?(c[1]="@media ".concat(c[2]," {").concat(c[1],"}"),c[2]=t):c[2]=t),r&&(c[4]?(c[1]="@supports (".concat(c[4],") {").concat(c[1],"}"),c[4]=r):c[4]="".concat(r)),e.push(c))}},e}},898:n=>{"use strict";n.exports=function(n){return n[1]}},372:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>v});var a=t(857),r=t.n(a),o=t(846),i=t.n(o),u=t(974),d=t.n(u),l=t(281),c=t.n(l),p=t(613),m=t.n(p),s=t(674),y=t.n(s),f=t(300),h={};h.styleTagTransform=y(),h.setAttributes=c(),h.insert=d().bind(null,"head"),h.domAPI=i(),h.insertStyleElement=m(),r()(f.A,h);const v=f.A&&f.A.locals?f.A.locals:void 0},857:n=>{"use strict";var e=[];function t(n){for(var t=-1,a=0;a<e.length;a++)if(e[a].identifier===n){t=a;break}return t}function a(n,a){for(var o={},i=[],u=0;u<n.length;u++){var d=n[u],l=a.base?d[0]+a.base:d[0],c=o[l]||0,p="".concat(l," ").concat(c);o[l]=c+1;var m=t(p),s={css:d[1],media:d[2],sourceMap:d[3],supports:d[4],layer:d[5]};if(-1!==m)e[m].references++,e[m].updater(s);else{var y=r(s,a);a.byIndex=u,e.splice(u,0,{identifier:p,updater:y,references:1})}i.push(p)}return i}function r(n,e){var t=e.domAPI(e);return t.update(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap&&e.supports===n.supports&&e.layer===n.layer)return;t.update(n=e)}else t.remove()}}n.exports=function(n,r){var o=a(n=n||[],r=r||{});return function(n){n=n||[];for(var i=0;i<o.length;i++){var u=t(o[i]);e[u].references--}for(var d=a(n,r),l=0;l<o.length;l++){var c=t(o[l]);0===e[c].references&&(e[c].updater(),e.splice(c,1))}o=d}}},974:n=>{"use strict";var e={};n.exports=function(n,t){var a=function(n){if(void 0===e[n]){var t=document.querySelector(n);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(n){t=null}e[n]=t}return e[n]}(n);if(!a)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");a.appendChild(t)}},613:n=>{"use strict";n.exports=function(n){var e=document.createElement("style");return n.setAttributes(e,n.attributes),n.insert(e,n.options),e}},281:(n,e,t)=>{"use strict";n.exports=function(n){var e=t.nc;e&&n.setAttribute("nonce",e)}},846:n=>{"use strict";n.exports=function(n){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var e=n.insertStyleElement(n);return{update:function(t){!function(n,e,t){var a="";t.supports&&(a+="@supports (".concat(t.supports,") {")),t.media&&(a+="@media ".concat(t.media," {"));var r=void 0!==t.layer;r&&(a+="@layer".concat(t.layer.length>0?" ".concat(t.layer):""," {")),a+=t.css,r&&(a+="}"),t.media&&(a+="}"),t.supports&&(a+="}");var o=t.sourceMap;o&&"undefined"!=typeof btoa&&(a+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o))))," */")),e.styleTagTransform(a,n,e.options)}(e,n,t)},remove:function(){!function(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n)}(e)}}}},674:n=>{"use strict";n.exports=function(n,e){if(e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},e={};function t(a){var r=e[a];if(void 0!==r)return r.exports;var o=e[a]={id:a,exports:{}};return n[a](o,o.exports,t),o.exports}let a;t.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return t.d(e,{a:e}),e},t.d=(n,e)=>{for(var a in e)t.o(e,a)&&!t.o(n,a)&&Object.defineProperty(n,a,{enumerable:!0,get:e[a]})},t.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),t.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.nc=void 0,t(372),document.getElementById("elenumberULA"),document.getElementById("ULAusr");let r=document.getElementById("codeULA");document.getElementById("runcodeULAbtn");const o=document.getElementById("outputULA");o.value="initializing...\n",document.getElementById("plot-containerframeULA");const i=document.getElementById("codeULAshow"),u=(document.getElementById("elenumberUPAx"),document.getElementById("elenumberUPAy"),document.getElementById("UPAphi"),document.getElementById("UPAtheta"),document.getElementById("codeUPA")),d=(document.getElementById("runcodeUPAbtn"),document.getElementById("outputUPA"));d.value="initializing...\n",document.getElementById("plot-containerframeUPA");const l=document.getElementById("codeUPAshow"),c=(document.getElementById("elenumberULAmult"),document.getElementById("ULAmultusr"),document.getElementById("disturb1dre"),document.getElementById("disturb2dre"),document.getElementById("codeULAmult")),p=(document.getElementById("runcodeULAmultbtn"),document.getElementById("outputULAmult"));p.value="initializing...\n",document.getElementById("plot-containerframeULAmult");const m=document.getElementById("codeULAmultshow");(async()=>{try{await async function(){return a=await loadPyodide({indexURL:"https://cdn.jsdelivr.net/pyodide/v0.18.1/full/"}),await a.loadPackage("numpy"),await a.loadPackage("micropip"),await a.loadPackage("matplotlib"),a}(),o.value="Pyodide initialized successfully.\n",d.value="Pyodide initialized successfully.\n",p.value="Pyodide initialized successfully.\n",i.value='# 引用库\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef ULAfunction(num_N,w):\n    """  \n    计算均匀线性阵列在不同角度下的增益。可以直接进行调用，不用编写。\n        \n    参数:  \n    num_N: int - 天线元素的数量  \n    w: numpy.array - 权重数组,形状为 (num_N,)\n        \n    返回:  \n    theta: numpy.array - 角度数组  \n    gain_ULA: numpy.array - 对应的增益数组  \n    """  \n    return theta,gain_ULA\n\ndef Modified_element(num_N, w, maxdre):\n    """ \n    用于计算最优天线选择矩阵，需要在右侧代码框中进行完成。\n    输入：\n    num_N: int - 天线元素的数量  \n    w: numpy.array - 权重数组,用于指示哪些天线元素处于开启状态,1表示开启,0表示关闭,默认为元素值均为1、长度为num_N的一维数组,如:[1,1,1,1,1,1,1,1]\n    maxdre: float - 用户方向（单位：°）\n    返回：\n    w: numpy.array - 优化后的权重数组,长度为num_N的一维数组,如:[1,0,0,1,1,1,1,1]\n    """ \n    return w\nw=np.ones(num_N) # 初始天线选择矩阵 \nw=Modified_element(num_N,w,maxdre) # 由Modified_element函数计算得到最优天线选择矩阵\n        \ntheta,gain_ULA=ULAfunction(num_N,w) # 利用已得到的最优天线选择矩阵计算增益\nfig = pltULA(theta,gain_ULA,maxdre) # 绘制增益图\n        ',r.value='def Modified_element(num_N, w, maxdre):\n    """ \n    用于计算最优天线选择矩阵，需要在本代码中进行完成。\n    输入：\n    num_N: int - 天线元素的数量  \n    w: numpy.array - 权重数组,用于指示哪些天线元素处于开启状态,1表示开启,0表示关闭,默认为元素值均为1、长度为num_N的一维数组,如:[1,1,1,1,1,1,1,1]\n    maxdre: float - 用户方向（单位：°）\n    """ \n    return w  \n    # w: numpy.array - 优化后的权重数组,长度为num_N的一维数组,如:[1,0,0,1,1,1,1,1]',l.value='import numpy as np\n\ndef steeringVectorUPA(Nx, Ny, theta, phi, w, dx=0.5, dy=0.5):  \n    """  \n    计算均匀平面阵列 (UPA) 的在(theta,phi)方向下的增益，可以直接进行调用，不用编写。  \n\n    参数:  \n    Nx: int - 阵列在 x 方向上天线元素的数量  \n    Ny: int - 阵列在 y 方向上天线元素的数量  \n    theta: float - 入射角的水平角度（单位：°）\n    phi: float - 入射角的垂直角度（单位：°）\n    w: numpy.array - 权重数组，用于指示哪些天线元素处于开启状态,1表示开启，0表示关闭\n    w的形状为(Nx, Ny)，形如\n    [[1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1]]\n    dx: float - 相邻天线在 x 方向上的间距（默认值为 0.5）  \n    dy: float - 相邻天线在 y 方向上的间距（默认值为 0.5）  \n\n    返回:  \n    A: numpy.array - 均匀平面阵列的波束形成方向向量，形状为 (Nx, Ny)  \n    """  \n    return A\ndef opt(Nx, Ny, w, theta, phi):  \n    """  \n    优化均匀平面阵列 (UPA) 的天线配置，以最大化在特定角度下的增益，需要在右侧代码框中进行编写。  \n\n    参数:  \n    Nx: int - 阵列在 x 方向上天线元素的数量  \n    Ny: int - 阵列在 y 方向上天线元素的数量  \n    w: numpy.array - 权重数组，用于指示哪些天线元素处于开启状态,1表示开启，0表示关闭\n    w默认为形状为(Nx, Ny)的全1数组，如：\n    [[1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1]]\n    theta: float - 入射角的水平角度（单位：°）\n    phi: float - 入射角的垂直角度（单位：°）\n    返回：\n    w: numpy.array - 计算得到的具有最大增益的阵列配置，形状为(Nx, Ny) 的二进制数组,其中 1 表示天线开启，0 表示天线关闭  \n    如：\n    [[1,0,1,1],\n    [1,1,1,1],\n    [1,0,1,1],\n    [1,1,1,0]]\n    """\n    return w\nw=np.ones((num_Nx, num_Ny), dtype=\'complex\')  # 初始天线选择矩阵\nw_opt=opt(num_Nx,num_Ny,w,theta,phi)  # 由opt函数计算得到最优天线选择矩阵\nplot = UPAfuction(num_Nx,num_Ny,w_opt) # 绘制增益图\n        ',u.value='def opt(Nx,Ny,w,theta,phi):\n    """  \n    优化均匀平面阵列 (UPA) 的天线配置，以最大化在特定角度下的增益，需要在本代码中编写。  \n\n    参数:  \n    Nx: int - 阵列在 x 方向上天线元素的数量  \n    Ny: int - 阵列在 y 方向上天线元素的数量  \n    w: numpy.array - 权重数组，用于指示哪些天线元素处于开启状态,1表示开启，0表示关闭\n    w默认为形状为(Nx, Ny)的全1数组，如：\n    [[1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1],\n    [1,1,1,1]]\n    theta: float - 入射角的水平角度（单位：°）\n    phi: float - 入射角的垂直角度（单位：°）\n    """\n    return w\n    """\n    返回：\n    w: numpy.array - 计算得到的具有最大增益的阵列配置，形状为(Nx, Ny) 的二进制数组,其中 1 表示天线开启，0 表示天线关闭  \n    如：\n    [[1,0,1,1],\n    [1,1,1,1],\n    [0,1,1,1],\n    [1,1,1,0]]\n    """',m.value='import numpy as np\nimport matplotlib.pyplot as plt\n\nk = 4  # 定义波束赋形矩阵w的相位传输比特数\nMM = 2 ** k  # 定义波束赋形矩阵w的相位分辨率\nfc = 2e9  # 定义中心频率，单位Hz\nc = 3e8  # 定义光速\nlamda = c / fc  # 计算波长,单位为m\nd = lamda / 2  # 定义天线间距\nN = 1000  # 定义角度采样点数\ntheta = np.pi * np.linspace(-1, 1, N + 1)  # 获得采样角度, theta 范围为 -pi/2 到 pi/2\nphi = np.zeros((N + 1, M))  # 初始化天线阵列响应向量的相位值\nstr_label = f\'M={M}, d=lambda/2\'\n\nfor j in range(M):\n    phi[:, j] = 2 * np.pi / lamda * (j - 1) * d * np.sin(theta)\n\nw = np.ones(M) # 初始天线选择矩阵\na = np.exp(1j * phi)  # 获得天线阵列响应向量\nAF = w @ a.T  # 计算天线阵列增益\n\ntheta_0 = maxdre / 180 * np.pi  # 定义服务用户的方向\ntheta_1 = disturb1d  / 180 * np.pi  # 定义干扰用户1的方向\ntheta_2 = disturb2dre / 180 * np.pi  # 定义干扰用户2的方向\n\n\ndef optimizedfuc(M, theta_0, theta_1, theta_2, w):  \n    """  \n    优化天线调相方案以最大化服务用户的信号增益，最小化干扰，需要在右侧代码框中进行编写。\n\n    参数:  \n    M: int - 天线元素的数量  \n    theta_0: float - 服务用户的方向（已转换为弧度表示）  \n    theta_1: float - 干扰用户1的方向（已转换为弧度表示）  \n    theta_2: float - 干扰用户2的方向（已转换为弧度表示）  \n    w: numpy.array - 初始天线调相方案，长度为M的一维数组，默认所有元素为1，如[1,1,1,1]\n\n    返回:  \n    w: numpy.array - 能够使SIR值最大的天线调相方案，形状为长度为M的一维数组。\n    需要注意的是，经过计算后得到的w中的值是单位幅度的复数，即它们的模长为1，而相位根据不同的量化配置而变化\n    例如：[1 + 0j, 0.7071 + 0.7071j, 0 + 1j, -0.7071 + 0.7071j]\n    """\n    return w\nw_opt=optimizedfuc(M,theta_0,theta_1,theta_2) # 由optimizedfuc函数计算得到最优天线调相方案\na = np.exp(1j * phi) # 获得天线阵列响应向量\nAF_opt = w_opt @ a.T # 计算最优天线阵列增益\n\n    ',c.value='def optimizedfuc(M,theta_0,theta_1,theta_2,w):\n    """  \n    用于计算能够最大化服务用户的SIR值的天线调相方案，需要在本代码中进行编写。\n    参数:  \n    M: int - 天线元素的数量  \n    theta_0: float - 服务用户的方向（已转换为弧度表示）  \n    theta_1: float - 干扰用户1的方向（已转换为弧度表示）  \n    theta_2: float - 干扰用户2的方向（已转换为弧度表示）  \n    w: numpy.array - 初始天线调相方案，长度为M的一维数组，默认所有元素为1，如[1,1,1,1]\n    """\n    return w\n    """\n    返回:  \n    w: numpy.array - 能够使SIR值最大的天线调相方案，形状为长度为M的一维数组。\n    需要注意的是，经过计算后得到的w中的值是单位幅度的复数，即它们的模长为1，而相位根据不同的量化配置而变化\n    例如：[1 + 0j, 0.7071 + 0.7071j, 0 + 1j, -0.7071 + 0.7071j]\n    """',console.log("Pyodide initialized successfully.")}catch(n){console.error("Error while initializing Pyodide:",n)}})()})();